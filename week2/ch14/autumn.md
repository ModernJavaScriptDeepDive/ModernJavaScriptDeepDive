## 14장. 전역 변수의 문제점

## 변수의 생명 주기

### 지역 변수

- 함수가 호출되면 생성되고 함수가 종료하면 소멸
- 함수 내부에 선언된 지역 변수는 함수가 호출되기 이전까지는 생성되지 않는다.

`remind` 변수 선언은 런타임에 실행되는 것이 아니라, 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행된다. 선언문이 어디에 있든 상관 없이 가장 먼저 실행된다. 👉 전역변수 한정!!

- 함수 내부에서 선언한 변수는 함수가 호출된 직후, 함수 몸체의 코드가 한 줄씩 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
- 지역 변수가 함수보다 오래 생존하는 경우 - 클로저!! 누군가가 스코프를 참조하고 있을 때

### 전역 변수

- 애플리케이션의 생명 주기와 같다. 전역 코드에는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다.
- var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 즉, 전역 변수 생명 주기 === 전역 객체 생명 주기
    - (참고) 전역 객체 : 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체. 브라우저에서는 window, Node.js에서는 global 객체. ES11에서 globalThis로 통일되었다.
    - 전역 객체가 갖는 프로퍼티 : 표준 빌트인 객체, 환경에 따른 호스트 객체(Web API 또는 호스트 API), var 키워드로 선언한 전역 변수와 전역 함수
- 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 게 JS의 가장 큰 문제점 중 하나
- var 키워드로 선언한 전역 변수, 함수 선언문으로 정의한 전역 함수, 암묵적 전역은 전역 객체 window의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 따라서 아래 코드는 같은 의미이다.

    ```jsx
    var x = 1;
    console.log(window.x); // 1
    console.log(x); // 1
    ```

### 전역 변수의 사용을 억제하는 방법

1. 즉시 실행 함수
    1. var 키워드 사용했을 때의 얘기인 듯
2. 네임스페이스 객체 - 식별자 충돌을 방지하는 효과는 있으나 넴스 객체 자체가 전역 변수에 할당되므로 그다지 유용하지 않음
    1. 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

        ```jsx
        var MYAPP = {}; // 전역 네임스페이스 객체
        MYAPP.name = 'Lee';
        console.log(MYAPP.name); // Lee
        ```

    2. 또 다른 네임스페이스 객체를 추가해서 계층적인 구성도 가능
3. 모듈 패턴
    1. 클래스를 모방해서, 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싼 것
    2. 클로저를 기반으로 동작
    3. 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있음 (캡슐화란, 프로퍼티와 메서드를 하나로 묶는 것)
4. ES6 모듈
    1. 파일 자체의 독자적인 모듈 스코프를 제공!!
    2. 모듈 내에서 var 키워드로 선언한 변수는 더이상 전역 변수도 아니고, window 객체의 프로퍼티도 아님
    3. `script` 태그에 `type="module"` 추가
