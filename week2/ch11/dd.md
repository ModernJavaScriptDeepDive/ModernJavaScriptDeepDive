# 원시 값과 객체의 비교

## 유삽 배열 객체

마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체. 대표적인 예시로 문자열이 있다.

## pass by sharing

ECMAScript 사양에 "값에 의한 전달(pass by value)"라는 용어는 등장하지 않는다. 타 언어에서 자주 사용하기에 차용할 뿐이다.

> 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

> 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다

## 객체

객체는 동적이라 필요한 메모리 공간을 사전에 정해 둘 수 없다.
객체는 복잡한 구조라서 브라우저 제조사마다 구현 방식이 다를 수 있다.
따라서 객체는 원시 값과는 다른 방식으로 동작하도록 설계 되어 있다. 

대부분의 자바스크립트 엔진은, 해시 테이블과 유사하지만 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다

자바, C++ 같은 언어는 클래스로 객체를 생성하는데, 객체가 생성 되기 전에 프로퍼티, 메소드가 정해져 있다. 이는 객체 생성 이후 프로퍼티, 메소드를 추가/삭제할 수 없다.

자바스크립트는 클래스 없이 객체를 생성하며 객체 생성 이후로도 동적으로 프로퍼티/메소드를 추가/삭제 할 수 있다. 편리하지만 성능상 비용이 많이 드는 비효율적 구조다.

V8 엔진은 프로퍼티에 접근하기 위해 동적 탐색 대신 **히든 클래스** 방식을 사용한다. 

## 객체는 왜 원시 값과 달리 값을 변경할 수 있을까

- 객체는 생성, 관리하는데 비용이 많이 든다.
- 객체를 변경할 때 마다 재생성 한다면 신뢰성은 확보되지만 
  - 객체는 크기가 매우 클 수 있고
  - 크기가 일정하지 않으며
  - 프로퍼티 값도 객체일 수 있다
- 즉, 복사에 비용이 많이 들기에 값을 변경하는게 더 효율적이다.
- 이러한 점 때문에 여러 개의 식별자가 하나의 객체를 공유할 수 있다 (단점?) 

## 자바스크립트에 참조에 의한 전달은 없다

- 실제로는 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 **원시 값이냐, 참조 값이냐**의 차이일 뿐. 즉 **값에 의한 전달**만 존재한다고 말할 수 있다.

다만 **공유에 의한 전달** 이라고 부르기도 하고, 사실 정확한 용어는 명세에 존재하지 않아서 논란?이 있다. 